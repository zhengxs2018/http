## API Report File for "@zhengxs/http"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { Agent } from 'node:http';
import { Readable } from 'node:stream';
import { ReadStream } from 'node:fs';

// @public (undocumented)
export abstract class AbstractPage<Item> implements AsyncIterable<Item> {
    // (undocumented)
    [Symbol.asyncIterator](): AsyncGenerator<Awaited<Item>, void, unknown>;
    constructor(client: APIClient, response: Response, body: unknown, options: FinalRequestOptions);
    // (undocumented)
    protected body: unknown;
    // (undocumented)
    getNextPage(): Promise<this>;
    // (undocumented)
    abstract getPaginatedItems(): Item[];
    // (undocumented)
    hasNextPage(): boolean;
    // (undocumented)
    iterPages(): AsyncGenerator<AbstractPage<Item>, void, unknown>;
    // (undocumented)
    abstract nextPageInfo(): PageInfo | null;
    // @deprecated (undocumented)
    abstract nextPageParams(): Partial<Record<string, unknown>> | null;
    // (undocumented)
    protected options: FinalRequestOptions;
    // (undocumented)
    protected response: Response;
}

// @public (undocumented)
export class APIClient {
    constructor({ baseURL, maxRetries, timeout, // 10 minutes
        httpAgent, fetch: overrideFetch, }: APIClientOptions);
    protected authHeaders(_opts: FinalRequestOptions): PromiseOrValue<ReqHeaders>;
    // (undocumented)
    baseURL: string;
    // (undocumented)
    protected buildRequest<Req extends NonNullable<unknown>>(options: FinalRequestOptions<Req>): Promise<{
        req: RequestInit_2;
        url: string;
        timeout: number;
    }>;
    // (undocumented)
    buildURL<Req extends Record<string, unknown>>(path: string, query: Req | null | undefined): string;
    // (undocumented)
    static create(baseURL: string, options?: Omit<APIClientOptions, 'baseURL'>): APIClient;
    protected defaultHeaders(opts: FinalRequestOptions): Promise<ReqHeaders>;
    // (undocumented)
    protected defaultIdempotencyKey(): string;
    // (undocumented)
    protected defaultQuery(): DefaultQuery | undefined;
    // (undocumented)
    delete<Req extends NonNullable<unknown>, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp>;
    // (undocumented)
    protected fetch: Fetch;
    // Warning: (ae-forgotten-export) The symbol "RequestInfo_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    fetchWithTimeout(url: RequestInfo_2, init: RequestInit_2 | undefined, ms: number, controller: AbortController): Promise<Response>;
    // (undocumented)
    get<Req extends NonNullable<unknown>, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp>;
    // (undocumented)
    getAPIList<Item, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(path: string, Page: new (...args: any[]) => PageClass, opts?: RequestOptions<any>): PagePromise<PageClass, Item>;
    // (undocumented)
    protected getRequestClient(): RequestClient;
    // (undocumented)
    protected getUserAgent(): string;
    // (undocumented)
    httpAgent: Agent | undefined;
    // (undocumented)
    protected idempotencyHeader?: string;
    // (undocumented)
    protected makeRequest(optionsInput: PromiseOrValue<FinalRequestOptions>, retriesRemaining: number | null): Promise<APIResponseProps>;
    // (undocumented)
    protected makeSimpleRequest(optionsInput: PromiseOrValue<FinalRequestOptions>, retriesRemaining?: number | null): Promise<APIResponseProps>;
    // (undocumented)
    protected makeStatusError(status: number | undefined, error: NonNullable<unknown> | undefined, message: string | undefined, headers: ReqHeaders | undefined): APIError;
    // (undocumented)
    maxRetries: number;
    // Warning: (ae-forgotten-export) The symbol "HeadersInit_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected parseHeaders(headers: HeadersInit_2 | null | undefined): Record<string, string>;
    // (undocumented)
    patch<Req extends NonNullable<unknown>, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp>;
    // (undocumented)
    post<Req extends NonNullable<unknown>, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp>;
    protected prepareRequest(_request: RequestInit_2, _config: {
        url: string;
        options: FinalRequestOptions;
    }): Promise<void>;
    // (undocumented)
    put<Req extends NonNullable<unknown>, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp>;
    // (undocumented)
    request<Req extends NonNullable<unknown>, Rsp>(options: PromiseOrValue<FinalRequestOptions<Req>>, remainingRetries?: number | null): APIPromise<Rsp>;
    // (undocumented)
    requestAPIList<Item = unknown, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass, options: FinalRequestOptions): PagePromise<PageClass, Item>;
    // (undocumented)
    simple<Req extends NonNullable<unknown>, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp>;
    // (undocumented)
    protected stringifyQuery(query: Record<string, unknown>): string;
    // (undocumented)
    timeout: number;
    protected validateHeaders(_headers: ReqHeaders, _customHeaders: ReqHeaders): void;
}

// @public (undocumented)
export interface APIClientOptions {
    // (undocumented)
    baseURL: string;
    // (undocumented)
    fetch?: Fetch | undefined;
    // (undocumented)
    httpAgent?: Agent | undefined;
    // (undocumented)
    maxRetries?: number | undefined;
    // (undocumented)
    timeout?: number | undefined;
}

// @public (undocumented)
export class APIConnectionError extends APIError {
    constructor({ message, cause, }: {
        message?: string;
        cause?: Error | undefined;
    });
    // (undocumented)
    readonly status: undefined;
}

// @public (undocumented)
export class APIConnectionTimeoutError extends APIConnectionError {
    constructor({ message }?: {
        message?: string;
    });
}

// @public (undocumented)
export class APIError extends HttpException {
    constructor(status: number | undefined, error: NonNullable<unknown> | undefined, message: string | undefined, headers: ReqHeaders | undefined);
    // (undocumented)
    readonly code: string | null | undefined;
    // (undocumented)
    readonly error: NonNullable<unknown> | undefined;
    // (undocumented)
    static generate(status: number | undefined, errorResponse: NonNullable<unknown> | undefined, message: string | undefined, headers: ReqHeaders | undefined): APIError;
    // (undocumented)
    readonly headers: ReqHeaders | undefined;
    // (undocumented)
    readonly param: string | null | undefined;
    // (undocumented)
    readonly status: number | undefined;
    // (undocumented)
    readonly type: string | undefined;
}

// @public
export class APIPromise<T> extends Promise<T> {
    constructor(responsePromise: Promise<APIResponseProps>, parseResponse?: (props: APIResponseProps) => PromiseOrValue<T>);
    asResponse(): Promise<Response>;
    // (undocumented)
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    // (undocumented)
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
    // (undocumented)
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    // (undocumented)
    _thenUnwrap<U>(transform: (data: T) => U): APIPromise<U>;
    withResponse(): Promise<{
        data: T;
        response: Response;
    }>;
}

// @public (undocumented)
export type APIResponseProps = {
    response: Response;
    options: FinalRequestOptions;
    controller: AbortController;
};

// @public (undocumented)
export class APIUserAbortError extends APIError {
    constructor({ message }?: {
        message?: string;
    });
    // (undocumented)
    readonly status: undefined;
}

// @public (undocumented)
export class AuthenticationError extends APIError {
    // (undocumented)
    readonly status: 401;
}

// @public (undocumented)
export class BadRequestError extends APIError {
    // (undocumented)
    readonly status: 400;
}

// @public
export interface BlobLike {
    readonly size: number;
    slice(start?: number, end?: number): BlobLike;
    text(): Promise<string>;
    readonly type: string;
}

// @public (undocumented)
type BlobPart_2 = string | ArrayBuffer | ArrayBufferView | Blob | Uint8Array | DataView;
export { BlobPart_2 as BlobPart }

// @public (undocumented)
export type Bytes = string | ArrayBuffer | Uint8Array | Buffer | null | undefined;

// @public (undocumented)
export const castToError: (err: any) => Error;

// @public (undocumented)
export class ConflictError extends APIError {
    // (undocumented)
    readonly status: 409;
}

// @public (undocumented)
export const createForm: <T = Record<string, unknown>>(body: T | undefined) => Promise<FormData>;

// @public (undocumented)
export const createResponseHeaders: (headers: Awaited<ReturnType<Fetch>>['headers']) => Record<string, string>;

// @public (undocumented)
export function debug(action: string, ...args: any[]): void;

// @public (undocumented)
export function defaultParseResponse<T>(props: APIResponseProps): Promise<T>;

// @public (undocumented)
export type DefaultQuery = Record<string, string | undefined>;

// @public (undocumented)
export type Fetch = (url: RequestInfo_2, init?: RequestInit_2) => Promise<Response>;

// @public
export interface FileLike extends BlobLike {
    readonly lastModified: number;
    readonly name: string;
}

// @public (undocumented)
export type FinalRequestOptions<Req extends NonNullable<unknown> = Record<string, unknown> | Readable> = RequestOptions<Req> & {
    method: HTTPMethod;
    path: string;
};

// @public (undocumented)
export function hasOwn(obj: NonNullable<unknown>, key: string): boolean;

// @public (undocumented)
export class HttpException extends Error {
}

// @public (undocumented)
export type HTTPMethod = 'get' | 'post' | 'put' | 'patch' | 'delete';

// @public (undocumented)
export class InternalServerError extends APIError {
}

// @public (undocumented)
export const isAbsoluteURL: (url: string) => boolean;

// @public
export const isBlobLike: (value: any) => value is BlobLike & {
    arrayBuffer(): Promise<ArrayBuffer>;
};

// @public (undocumented)
export function isEmptyObj(obj: NonNullable<unknown> | null | undefined): boolean;

// @public (undocumented)
export const isFileLike: (value: any) => value is FileLike;

// Warning: (ae-forgotten-export) The symbol "MultipartBody" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const isMultipartBody: (body: any) => body is MultipartBody;

// @public (undocumented)
export const isRequestOptions: (obj: unknown) => obj is RequestOptions<Record<string, unknown> | Readable>;

// @public (undocumented)
export const isResponseLike: (value: any) => value is ResponseLike;

// @public (undocumented)
export const isUploadable: (value: any) => value is Uploadable;

// @public (undocumented)
export type KeysEnum<T> = {
    [P in keyof Required<T>]: true;
};

// @public
export class LineDecoder {
    constructor();
    // (undocumented)
    buffer: string[];
    // (undocumented)
    decode(chunk: Bytes): string[];
    // (undocumented)
    decodeText(bytes: Bytes): string;
    // (undocumented)
    flush(): string[];
    // (undocumented)
    static NEWLINE_CHARS: Set<string>;
    // (undocumented)
    static NEWLINE_REGEXP: RegExp;
    // (undocumented)
    textDecoder: any;
    // (undocumented)
    trailingCR: boolean;
}

// @public
export const maybeMultipartFormRequestOptions: <T extends {} = Record<string, unknown>>(opts: RequestOptions<T>) => Promise<RequestOptions<MultipartBody | T>>;

// @public (undocumented)
export const multipartFormRequestOptions: <T extends {} = Record<string, unknown>>(opts: RequestOptions<T>) => Promise<RequestOptions<MultipartBody | T>>;

// @public (undocumented)
export class NotFoundError extends APIError {
    // (undocumented)
    readonly status: 404;
}

// @public (undocumented)
export type PageInfo = {
    url: URL;
} | {
    params: Record<string, unknown> | null;
};

// @public
export class PagePromise<PageClass extends AbstractPage<Item>, Item = ReturnType<PageClass['getPaginatedItems']>[number]> extends APIPromise<PageClass> implements AsyncIterable<Item> {
    [Symbol.asyncIterator](): AsyncGenerator<Awaited<Item>, void, unknown>;
    constructor(client: APIClient, request: Promise<APIResponseProps>, Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass);
}

// @public (undocumented)
export class PermissionDeniedError extends APIError {
    // (undocumented)
    readonly status: 403;
}

// @public (undocumented)
export type PromiseOrValue<T> = T | Promise<T>;

// @public (undocumented)
export class RateLimitError extends APIError {
    // (undocumented)
    readonly status: 429;
}

// @public
export function readableStreamAsyncIterable<T>(stream: any): AsyncIterableIterator<T>;

// @public (undocumented)
export type ReqHeaders = Record<string, string | null | undefined>;

// @public (undocumented)
export type RequestClient = {
    fetch: Fetch;
};

// @public (undocumented)
export type RequestOptions<Req extends NonNullable<unknown> = Record<string, unknown> | Readable> = {
    method?: HTTPMethod;
    path?: string;
    query?: Req | undefined;
    body?: Req | undefined;
    headers?: ReqHeaders | undefined;
    maxRetries?: number;
    stream?: boolean | undefined;
    timeout?: number;
    httpAgent?: Agent;
    signal?: AbortSignal | undefined | null;
    idempotencyKey?: string;
    duplex?: boolean;
    __binaryResponse?: boolean | undefined;
};

// @public
export interface ResponseLike {
    // (undocumented)
    blob(): Promise<BlobLike>;
    // (undocumented)
    url: string;
}

// @public (undocumented)
export const safeJSON: (text: string) => any;

// @public (undocumented)
export type ServerSentEvent = {
    event: string | null;
    data: string;
    raw: string[];
};

// @public (undocumented)
export const sleep: (ms: number) => Promise<unknown>;

// @public (undocumented)
export class SSEDecoder {
    constructor();
    // (undocumented)
    decode(line: string): ServerSentEvent | null;
}

// @public (undocumented)
export class Stream<Item> implements AsyncIterable<Item> {
    // (undocumented)
    [Symbol.asyncIterator](): AsyncIterator<Item>;
    constructor(iterator: () => AsyncIterator<Item>, controller: AbortController);
    // (undocumented)
    controller: AbortController;
    static fromReadableStream<Item>(readableStream: globalThis.ReadableStream, controller: AbortController): Stream<Item>;
    // (undocumented)
    static fromSSEResponse<Item>(response: Response, controller: AbortController): Stream<Item>;
    tee(): [Stream<Item>, Stream<Item>];
    toReadableStream(): globalThis.ReadableStream;
}

// @public
export function toFile(value: ToFileInput | PromiseLike<ToFileInput>, name?: string | null | undefined, options?: FilePropertyBag | undefined): Promise<FileLike>;

// Warning: (ae-forgotten-export) The symbol "BlobLikePart" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type ToFileInput = Uploadable | Exclude<BlobLikePart, string> | AsyncIterable<BlobLikePart>;

// @public (undocumented)
export class UnprocessableEntityError extends APIError {
    // (undocumented)
    readonly status: 422;
}

// @public
export type Uploadable = FileLike | ResponseLike | ReadStream;

// @public
export const uuid4: () => string;

// @public (undocumented)
export const validatePositiveInteger: (name: string, n: unknown) => number;

// Warnings were encountered during analysis:
//
// dist-types/client.d.ts:85:9 - (ae-forgotten-export) The symbol "RequestInit_2" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
